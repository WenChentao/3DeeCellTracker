import matplotlib.pyplot as plt
import numpy as np
from numpy import ndarray
import pandas as pd
import plotly.graph_objects as go

from CellTracker.v1_modules.ffn import initial_matching_ffn, FFN
from CellTracker.utils import normalize_points
from CellTracker.robust_match import add_or_remove_points
from CellTracker.trackerlite import BETA, LAMBDA, K_POINTS, get_match_pairs, cal_norm_prob, \
    predict_new_positions, plot_initial_matching


def match_coords_to_ids(ffn_model_path: str, coordinates_nx3: ndarray, path_to_neuropal_csv: str, skiprows: int = 0) -> ndarray:
    """
    Match coordinates to ids from a csv file. The csv file is generated by Neuropal. The coordinates are matched to the
    ids by finding the closest coordinates in the csv file to the coordinates to be matched.

    Parameters
    ----------
    ffn_model_path: str
        path to the trained FFN model
    coordinates_nx3: ndarray
        coordinates to be matched
    path_to_neuropal_csv: str
        path to csv file containing ids and coordinates
    skiprows: int
        number of rows to skip when reading csv file
    """
    # Read ids and coordinates from csv file. The first ? rows are information about the file. The 8th row is the header.
    # The ids are stored in the "User ID" column and the coordinates are stored in the "Real X (um)", "Real Y (um)" and "
    # Real Z (um)" columns.
    # Note that Real Y corresponds to Height and Real X corresponds to Width in the Neuropal GUI.
    df = pd.read_csv(path_to_neuropal_csv, skiprows=skiprows)
    ids = df["User ID"].values
    coordinates = df[["Real Y (um)", "Real X (um)", "Real Z (um)"]].values
    predict_cell_positions(ffn_model_path, coordinates, coordinates_nx3, ids_neuropal=ids)


def predict_cell_positions(ffn_model_path: str, coords_neuropal: ndarray, coords_wba: ndarray,
                           beta: float = BETA, lambda_: float = LAMBDA, smoothing=0,
                           post_processing: str = "prgls", filter_points: bool = True, verbosity: int = 4,
                           match_method="coherence", similarity_threshold: float = 0.4, ids_neuropal = None):
    """
    Predict
    """
    ffn_model = FFN()
    try:
        dummy_input = np.random.random((1, 122))
        _ = ffn_model(dummy_input)
        ffn_model.load_weights(str(ffn_model_path))
    except (OSError, ValueError) as e:
        raise ValueError(f"Failed to load the FFN model from {ffn_model_path}: {e}") from e

    # Normalize point sets
    neuropal_coords_norm_t2, (mean_t1, scale_t1) = normalize_points(coords_neuropal, return_para=True)
    confirmed_coords_norm_t1, (mean_t2, scale_t2) = normalize_points(coords_wba, return_para=True)

    filtered_coords_norm_t1 = confirmed_coords_norm_t1.copy()
    filtered_coords_norm_t2 = neuropal_coords_norm_t2.copy()
    n = confirmed_coords_norm_t1.shape[0]
    m = neuropal_coords_norm_t2.shape[0]
    inliers_ori = np.arange(n), np.arange(m)
    for i in range(4):
        similarity_scores = initial_matching_ffn(ffn_model, filtered_coords_norm_t1,
                                                 filtered_coords_norm_t2,
                                                 K_POINTS)
        updated_similarity_scores = similarity_scores.copy()
        updated_matched_pairs = get_match_pairs(updated_similarity_scores, filtered_coords_norm_t1,
                                        filtered_coords_norm_t2, threshold=similarity_threshold,
                                        method=match_method)
        normalized_prob = cal_norm_prob(updated_matched_pairs, updated_similarity_scores.shape)

        if verbosity >= 2 and i == 0:
            fig = plot_initial_matching(filtered_coords_norm_t1,
                                  filtered_coords_norm_t2,
                                  updated_matched_pairs, 1, -1, ids_tgt=ids_neuropal, ids_ref=list(range(1, n+1)))
            fig.suptitle("Initial matching by FFN", fontsize=20, y=0.9)
        if verbosity >= 3 and i > 0:
            fig = plot_initial_matching(filtered_coords_norm_t1,
                                  filtered_coords_norm_t2,
                                  updated_matched_pairs, 1, -1)
            fig.suptitle(f"Updated matching (iteration={i}))", fontsize=20, y=0.9)
        predicted_coords_t1_to_t2 = predict_new_positions(
            updated_matched_pairs, filtered_coords_norm_t1, filtered_coords_norm_t1, filtered_coords_norm_t2,
            post_processing, smoothing, normalized_prob, beta, lambda_)

        if filter_points:
            predicted_coords_t2_to_t1 = predict_new_positions(
                updated_matched_pairs[:, [1, 0]], filtered_coords_norm_t2, filtered_coords_norm_t2, filtered_coords_norm_t1,
                post_processing, smoothing, normalized_prob.T, beta, lambda_)
            filtered_coords_norm_t1, filtered_coords_norm_t2, inliers = \
                add_or_remove_points(
                predicted_coords_t1_to_t2, predicted_coords_t2_to_t1, filtered_coords_norm_t1, filtered_coords_norm_t2,
                updated_matched_pairs, k_neighbors=3)
            inliers_pre = (inliers_ori[0], inliers_ori[1])
            inliers_ori = inliers_ori[0][inliers[0]], inliers_ori[1][inliers[1]]


    original_matched_pairs = np.column_stack((inliers_pre[0][updated_matched_pairs[:, 0]], inliers_pre[1][updated_matched_pairs[:, 1]]))

    # normalized_prob = cal_norm_prob(original_matched_pairs, similarity_scores_shape)
    # tracked_coords_norm_t2 = predict_new_positions(original_matched_pairs, confirmed_coords_norm_t1,
    #                                                confirmed_coords_norm_t1, neuropal_coords_norm_t2,
    #                                                post_processing, smoothing, normalized_prob, beta, lambda_)
    if verbosity >= 0:
        print(f"Matching method: {match_method}")
        print(f"Threshold for similarity: {similarity_threshold}")
        print(f"Post processing method: {post_processing}")
    if verbosity >= 1:
        fig = plot_initial_matching(confirmed_coords_norm_t1,
                                    neuropal_coords_norm_t2,
                                    original_matched_pairs,
                                    t1=1, t2=-1,
                                    fig_width_px=2400,
                                    ids_tgt=ids_neuropal, ids_ref=list(range(1, n+1)))
        fig.suptitle("Final matching", fontsize=20, y=0.9)
        plt.pause(0.1)
        shift = (0.5, 0, 0)
        fig = plot_initial_matching_with_plotly(neuropal_coords_norm_t2,confirmed_coords_norm_t1,
                                      original_matched_pairs[:, [1, 0]],
                                      ids_ref=ids_neuropal, ids_tgt=list(range(1, n+1)), shift=shift)
        fig.update_layout(width=1500, height=1000,
            title='Final matching'  # <-- Add this line to set the title
        )
        fig.show()
    return


def plot_initial_matching_with_plotly(neuropal_ptrs: np.ndarray, wba_ptrs: np.ndarray, pairs_px2: np.ndarray,
                                      ids_ref=None, ids_tgt=None, shift=(0, 0, 0)):
    """
    Draws the initial matching between two sets of 3D points and their matching relationships using Plotly.

    Args:
        neuropal_ptrs (np.ndarray): A 2D array of shape (n, 3) containing the reference points.
        wba_ptrs (np.ndarray): A 2D array of shape (n, 3) containing the target points.
        pairs_px2 (np.ndarray): A 2D array of shape (m, 2) containing the pairs of matched points.
    """

    # Validate the inputs
    assert isinstance(neuropal_ptrs, np.ndarray) and neuropal_ptrs.ndim == 2 and neuropal_ptrs.shape[1] == 3, \
        "ref_ptrs should be a 2D array with shape (n, 3)"
    assert isinstance(wba_ptrs, np.ndarray) and wba_ptrs.ndim == 2 and wba_ptrs.shape[1] == 3, \
        "tgt_ptrs should be a 2D array with shape (n, 3)"
    assert isinstance(pairs_px2, np.ndarray) and pairs_px2.ndim == 2 and pairs_px2.shape[1] == 2, \
        "pairs_px2 should be a 2D array with shape (n, 2)"

    neuropal_ptrs = neuropal_ptrs + np.asarray(shift)[np.newaxis, :]

    # Create the figure
    fig = go.Figure()

    # Add scatter plots for the reference and target points
    fig.add_trace(go.Scatter(x=neuropal_ptrs[:, 1], y=-neuropal_ptrs[:, 0],
                             mode='markers', name='NeuroPAL Points',
                             text=ids_ref, marker=dict(size=10, color='blue')))
    fig.add_trace(go.Scatter(x=wba_ptrs[:, 1], y=-wba_ptrs[:, 0],
                             mode='markers', name='WBA Points',
                             text=ids_tgt, marker=dict(size=10, color='red')))

    # Add lines for the matching relationships
    for ref_index, tgt_index in pairs_px2:
        fig.add_shape(type="line",
                      x0=neuropal_ptrs[ref_index, 1], y0=-neuropal_ptrs[ref_index, 0],
                      x1=wba_ptrs[tgt_index, 1], y1=-wba_ptrs[tgt_index, 0],
                      line=dict(color="green", width=2))

    # Update the layout
    fig.update_layout(title="Initial Matching of Point Sets",
                      xaxis_title="X", yaxis_title="Y",
                      autosize=True, hovermode="closest")

    return fig

